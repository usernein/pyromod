"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7849],{680:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var t=n(5893),i=n(1151);const o={title:"v2.0.0"},r=void 0,a={id:"release-notes/v2-0-0",title:"v2.0.0",description:"+ It became easier to create simple inline keyboards. You can now pass a string as button, which will be used as text and callback_data:",source:"@site/docs/release-notes/v2-0-0.md",sourceDirName:"release-notes",slug:"/release-notes/v2-0-0",permalink:"/release-notes/v2-0-0",draft:!1,unlisted:!1,editUrl:"https://github.com/usernein/pyromod/tree/master/docs/docs/release-notes/v2-0-0.md",tags:[],version:"current",frontMatter:{title:"v2.0.0"},sidebar:"releaseNotesSidebar",previous:{title:"v3.1.0 (latest)",permalink:"/release-notes/v3-1-0"},next:{title:"v2.1.0",permalink:"/release-notes/v2-1-0"}},l={},d=[];function c(e){const s={a:"a",code:"code",em:"em",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"It became easier to create simple inline keyboards. You can now pass a string as button, which will be used as text and callback_data:"}),"\n"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'keyboard = ikb([\n    ["Earth", "Mars", "Venus"],\n    ["Saturn", "Jupyter"]\n])\n'})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["Added support for listening for buttons. You can use await ",(0,t.jsx)(s.code,{children:"Message.wait_for_click()"})," to await for any click on any button on that message. By passing an ",(0,t.jsx)(s.code,{children:"user_id"})," into the parameter ",(0,t.jsx)(s.code,{children:"from_user_id"}),", you can restrict from which users should the bot accept the click. Any other user will see an alert (",(0,t.jsx)(s.em,{children:"i.e. query.answer()"}),") informing they are not supposed to click the button. You can pass a custom text to the param ",(0,t.jsx)(s.code,{children:"alert"})," or can pass False to disable it, so no text will be shown at all.\n",(0,t.jsx)(s.img,{src:"https://user-images.githubusercontent.com/29507335/213792781-2b6aa7de-ce0f-4d98-915e-7d46246e1bb3.png",alt:"image"})]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["To support both messages and callback queries, a parameter named ",(0,t.jsx)(s.code,{children:"listener_type"})," has been added. Its value must be one of the enum ",(0,t.jsx)(s.code,{children:"pyromod.ListenerTypes"})]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["The method ",(0,t.jsx)(s.em,{children:"cancel_listener"})," has been renamed to ",(0,t.jsx)(s.code,{children:"stop_listening"})]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:['Pyromod now uses "identifiers" in all its methods instead of the good old chat_id. Identifiers are basically tuples with ordered data about the messages that the listeners should listen for. It must follow this order: ',(0,t.jsx)(s.code,{children:"(chat_id, user_id, message_id)"}),". If you pass None as value, it will act as a wildcard, matching any value. Examples:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"(1029384756, 276145711, None)"}),' means "any message sent by 276145711 in the chat 1029384756"']}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"(1029384756, None, None)"}),' means "any message sent in the chat 1029384756, from any user"']}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"(None, 276145711, None)"}),' means "any message from 276145711 on any chat"']}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"message_id is only used when waiting for button clicks:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"(1029384756, 276145711, 1123)"}),' means "a click done by 276145711 on a button on the message 1123 on the chat 1029384756"']}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"(1029384756, None, 1123)"}),' means "a click on a button on the message 1123 on the chat 1029384756, done by any user"\nThe listeners are used as patterns for matching against the received update data. A listener with the identifier/pattern ',(0,t.jsx)(s.code,{children:"(1029384756, 276145711, None)"})," will match if the message data is ",(0,t.jsx)(s.code,{children:"(1029384756, 276145711, 728)"}),", but won't do if the message data is ",(0,t.jsx)(s.code,{children:"(1029384756, 200097591, 729)"}),", because the identifier specified which user_id it wants and it\u2032s not matching.\nIf you use mostly the bound methods, you don\u2032t need to worry about it, since they will automatically compose the identifier for you."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["m.chat.listen will compose ",(0,t.jsx)(s.code,{children:"(m.chat.id, None, None)"})]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["m.from_user.listen will compose ",(0,t.jsx)(s.code,{children:"(None, m.from_user.id, None)"})]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["m.from_user.ask will compose ",(0,t.jsx)(s.code,{children:"(m.from_user.id, m.from_user.id, None)"})]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["m.wait_for_click(from_user_id=276145711) will compose ",(0,t.jsx)(s.code,{children:"(m.chat.id, 276145711, m.id)"})]}),"\n",(0,t.jsxs)(s.p,{children:["Be aware that User.listen does not create a listener for messages sent by the user on the chat of the message. If using ",(0,t.jsx)(s.code,{children:"User.ask"}),", it asks on the private chat with the user and creates a listener for messages sent by the user on the private conversation. This may change in the future to whatever makes more sense. If using ",(0,t.jsx)(s.code,{children:"User.listen"}),", it will listen for any message from that user, anywhere."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["Pyromod now raises ",(0,t.jsx)(s.code,{children:"pyromod.ListenerTimeout(timeout)"})," instead of ",(0,t.jsx)(s.em,{children:"asyncio.TimeoutError"})]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["New exception ",(0,t.jsx)(s.code,{children:"pyromod.ListenerStopped"}),". It raises when any listener is stopped by ",(0,t.jsx)(s.code,{children:"Client.stop_listening"})]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["New class ",(0,t.jsx)(s.code,{children:"pyromod.PyromodConfig"}),". It\u2032s a class with some static properties that hold some tweaks and error handlers."]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"timeout_handler"}),": a callback that gets executed instead of raising ",(0,t.jsx)(s.em,{children:"asyncio.TimeoutError"})," (now ",(0,t.jsx)(s.code,{children:"pyromod.ListenerTimeout"}),"). It receives ",(0,t.jsx)(s.code,{children:"(identifier, listener_data, timeout)"})," as arguments."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"stopped_handler"}),": a callback that gets executed when a listener is stopped by ",(0,t.jsx)(s.code,{children:"stop_listening()"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"throw_exceptions"}),": Boolean, defaults to True. If False, pyromod won't raise none of ",(0,t.jsx)(s.code,{children:"pyromod.ListenerTimeout"})," and ",(0,t.jsx)(s.code,{children:"pyromod.ListenerStopped"}),". The functions should just return None instead."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"unallowed_user_alert"}),": Boolean, defaults to True. If False, no text will be responded to unwanted user clicks."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"unallowed_user_alert_text"}),": the default text for unallowed user alerts.\n",(0,t.jsx)(s.img,{src:"https://user-images.githubusercontent.com/29507335/213794327-1bcce3d0-6e01-453a-b529-529833821173.png",alt:"image"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Before this release, pyromod would block other commands to work if there is a listener on the chat, but the filters doesn't match (i.e. a listener with filters.photo, but the message is just text). Now, if there\u2032s a listener but the filters doesn't match, the message will keep propagating to other handlers. The same happens when you use a restrictive identifier, specifying the user_id. In this case, all other users will still be able to use the bot, while the bot keeps awaiting for a message from the wanted user. As it should be."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["The parameters for ",(0,t.jsx)(s.code,{children:"stop_listening"})," (formerly cancel_listener) has changed, due to the addition of identifiers. Before this release, you could pass the chat_id of the listener to stop and delete it. Now, with identifiers, you can either pass a message data as ",(0,t.jsx)(s.code,{children:"(chat_id, user_id, message_id)"})," to stop the first matching listener or pass a ",(0,t.jsx)(s.code,{children:"identifier_pattern"})," to stop the first matching listeners."]}),"\n",(0,t.jsxs)(s.p,{children:["To explain the difference between these two, let\u2032s suppose you want to stop a listener that has ",(0,t.jsx)(s.code,{children:"(1029384756, 276145711, 19876)"})," as identifier, but you only know the chat_id, so you can't pass the message data to match.\nIn this case, you can pass ",(0,t.jsx)(s.code,{children:"identifier_pattern=(1029384756, None, None)"}),".\nThis also may change in the near future, I honestly don't know why there is two ways, where identifier_pattern could handle both situations. I was sleepy.\n",(0,t.jsx)(s.img,{src:"https://user-images.githubusercontent.com/29507335/213794923-efde145c-ad64-4515-a392-04f21c9875e0.png",alt:"image"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Full Changelog"}),": ",(0,t.jsx)(s.a,{href:"https://github.com/usernein/pyromod/compare/v1.5...v2.0.0",children:"https://github.com/usernein/pyromod/compare/v1.5...v2.0.0"})]})]})}function h(e={}){const{wrapper:s}={...(0,i.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},1151:(e,s,n)=>{n.d(s,{Z:()=>a,a:()=>r});var t=n(7294);const i={},o=t.createContext(i);function r(e){const s=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:s},e.children)}}}]);